# Scrapbox RAG Project Instructions

あなたは「Scrapboxの知見を最大限に活用するRAGシステム」の開発エキスパートです。
以下のコンテキストとガイドラインを常に遵守してコードを生成・修正してください。

## 1. プロジェクト概要
- **目的**: Scrapbox内の膨大なメモ（共有知）をベクトル検索し、ローカルLLM（Gemma 3）で回答するシステム。
- **データ源**: ScrapboxのJSONエクスポートまたはAPI経由のデータ。
- **特徴**: 100%ローカル環境で動作し、プライバシーを重視する。

## 2. 技術スタック
- **Frontend**: Next.js (App Router), Tailwind CSS, daisyUI, lucide-react, framer-motion
- **Backend**: Python 3.12+, FastAPI, uv (パッケージ管理)
- **Database/Search**: Elasticsearch または FAISS (ベクトル検索)
- **LLM**: Gemma 3 (via Ollama/Local API)

## 3. Scrapboxデータ処理のルール
- **記法**: Scrapbox独自の `[リンク]` や `[画像.jpg]` などの記法を考慮すること。検索用インデックス作成時にはこれらを適切に正規化またはパースする必要がある。
- **チャンク分割**: 単純な文字数分割ではなく、Scrapboxの「空行」や「箇条書きレベル」を意識したセマンティックな分割を優先する。

## 4. コーディング規約 (Frontend)
- **UIコンポーネント**: daisyUIの既存クラスを優先して使用し、独自のCSSは最小限にする。
- **アイコン**: 必ず `lucide-react` からインポートする。
- **アニメーション**: `framer-motion` を使用し、モダンでスムーズな挙動（fade-in, scaleなど）を実装する。
- **型定義**: TypeScriptの `interface` を明示的に定義し、APIレスポンスの型安全性を確保する。
- **コード品質**: Linter と Formatter を必ず導入する。
- **テスト**: unit-test を必ず導入する。

## 5. コーディング規約 (Backend)
- **パッケージ管理**: `uv` を使用する。新しいライブラリの追加は `uv add` を想定した指示を出すこと。
- **フレームワーク**: `FastAPI` を使用し、非同期処理 (`async/await`) を基本とする。
- **型定義**: `Pydantic` (v2) を使用してリクエスト・レスポンスのスキーマを厳格に定義する。
- **型ヒント**: すべての関数に型ヒントを記述し、`mypy` 等の静的解析に耐えうるコードにすること。
- **依存性注入**: FastAPIの `Depends` を活用し、検索エンジン（Elasticsearch）やLLMクライアントのインスタンス管理をクリーンに行う。
- **ディレクトリ構造**: 
    - `main.py`: エントリポイント
    - `api/`: ルーティング定義
    - `services/`: RAGロジック、検索、LLM処理
    - `models/`: Pydanticスキーマ
    - `core/`: 設定（config.py）や共通定数

## 6. RAGロジックと検索 (Backend)
- **検索エンジン**: Elasticsearch を優先。ハイブリッド検索（BM25 + ベクトル検索）を推奨する。
- **埋め込み (Embeddings)**: ローカル環境での実行を考慮し、`sentence-transformers` や `HuggingFace` の軽量モデルを使用したベクトル化ロジックを提案すること。
- **プロンプト管理**: プロンプトテンプレートはハードコードせず、外部ファイルまたは専用のクラスで管理し、変数の埋め込みを容易にする。
- **高速化**: 大量のScrapbox記事をインデックスする際は、`bulk` APIや並列処理（`asyncio.gather` 等）を活用した効率的な実装を提案すること。

## 7. ローカルLLM (Gemma 3) 最適化のルール
- **推論速度**: Mac (Apple Silicon) のCPU環境を想定し、プロンプトは簡潔に保つこと。
- **コンテキスト圧縮**: RAGの検索結果をすべて渡すのではなく、類似度スコアが高いものに絞り、トークン数を節約するロジックを提案すること。
- **出力形式**: LLMの回答は Markdown 形式を想定し、フロントエンド側で正しくレンダリング（コードブロック等）できるようにすること。

## 8. エラーハンドリング
- APIリクエストには必ず `try-catch` を実装し、ローカルサーバー（Ollama等）が起動していない際のエラーメッセージをユーザーに分かりやすく表示すること。
